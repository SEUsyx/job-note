# 操作系统的基本概念和流程

## 操作系统的接口
关键函数：对计算机硬件进行使用 
应用软件->操作系统->计算机硬件

重要的系统调用（操作系统接口），主要分为两类：
任务管理：fork：创建一个进程
         execl：执行一个可执行程序
         pthread_create：创建一个线程
文件系统：open：打开一个文件或目录
         EACCES：返回值，表示没有权限
         mode_t st_mode：文件头结构；文件属性


## 系统调用的实现
直观想法：为什么不直接跳进内存？ 不允许，不能随意调用内存数据！！！
概念：系统调用：提供一种进入系统内核的办法

隔离内核程序和用户程序：层级结构（由内到外）：核心态|OS服务|用户态 用户态的程序是不能跳往核心态的，必须通过操作系统访问
手段：通过硬件设计实现，两个段寄存器：CS 和 DS
用代码段寄存器CS的低两位表示当前程序是执行在什么态（CPL, Current Privilege Level）：0是内核态，3是用户态
用数据段寄存器DS的低两位表示访问该段的权限级别(DPL, Descriptor Privilege Level)，放在GDP表中
RPL说明的是进程对段访问的请求权限(RPL，Request Privilege Level)

执行程序时：CS:IP是当前指令，用户态的CPL为3，内核态的CPL为0
检查：DPL >= max(CPL, RPL) 内核态可以访问任何数据，用户态不能访问内核数据

进入内核的唯一方法：中断指令int：中断指令使CS中CPL改为0，可以进入内核
系统调用的核心：一段包含int指令的代码；操作系统写中断处理，获取想调用程序的编号；操作系统根据编号执行相应的代码

例子：printf()
- 应用程序使用printf()
  - 调用C函数库中的函数printf() 
      - 使用_syscall3()对应用程序中的函数的参数格式进行转换
  - 调用库函数write() 
      - 通过宏定义展开成一段包含int指令的汇编程序
  - 系统调用write() 

int 0X80 的中断处理：

中断处理：system_call() 
查表：system_call_table()
系统调用号：_NR_write=4
系统调用：sys_write()