# 进程间的通信(IPC: Inter Process Communication)

- 目的:
  - 数据传输
  - 通知事件:一个进程向另一个进程发送消息,通知发生了某种事件
  - 资源共享:多个进程之间共享资源,需要内核提供互斥和同步机制
    - 同步:多个进程之间有序进行资源的操作
    - 异步:多个进程同时进行资源操作,会带来安全问题
  - 进程控制:控制另一个进程的执行

- 进程间通信的方式
  - 同一主机
    - unix进程间的通信方式:
      - 匿名管道
      - 有名管道
      - 信号
    - systemV进程间通信方式,POSIX进程间通信方式
      - 消息队列
      - 共享内存
      - 信号量
  - 不同主机
    - Socket


### 匿名管道
- unix系统IPC的最古老的形式
- 管道符:|
- 特点:
  - 管道其实是一个在*内核内存*中维护的缓冲器,这个缓冲器的能力是有限的,不同的操作系统大小不一定相同
  - 管道拥有文件的特质:可以进行读操作,写操作,匿名管道没有文件实体,有名管道有文件实体,但不存储数据.可以按照操作文件的方式对管道进行操作
  - 一个管道是一个字节流,使用管道时不存在消息或消息边界的概念,从管道读取数据的进程可以读取任意大小的数据块,而不管写入进程的数据块的大小是多少
  - 通过管道传递的数据是顺序的,从管道中读取的字节顺序和他们被写入的顺序是完全一样的,环形队列
  - 管道中的数据传输方向是单向的,一端用于写入,一端用于读取,管道是半双工的
    - 单工:电视遥控器,只能向传输
    - 半双工:对讲机,可以双向传输,但是同一时刻只能单项传输
    - 双工:电话,可以双向同时传输
  - 管道读数据是一次性操作,数据一旦被读走,就从管道中被抛弃,释放空间以便写更多的数据
  - 匿名管道只能在具有公共祖先的进程(父子进程,兄弟进程,具有亲缘关系)之间使用
    - 原因:进程fork之后共享文件描述符表

- 系统调用
  - 创建匿名管道:int pipe(int pipefd[2]);
    - 功能:创建管道,用来进行IPC
    - 参数:
      - pipefd[2]:管道的两端,传出参数
        - pipefd[0]:管道的读端
        - pipefd[1]:管道的写端
    - 返回值:
        - 成功:0
        - 失败:-1
    - 注意:
      - 匿名管道只能在具有公共祖先的进程(父子进程,兄弟进程,具有亲缘关系)之间使用
      - 在fork之前创建管道
      - 管道默认是阻塞的:如果管道没有数据, read阻塞; 如果管道满了,write阻塞(不严谨)
        - 严谨说法,分为一下具体情况:
          - 读管道:
            - 管道中有数据:read返回实际读到的字节数
            - 管道中无数据:             
              - 写端全部关闭(引用计数为0):read返回0(相当于读到文件末尾)
              - 写端没有完全关闭:read阻塞
          - 写管道:
            - 读端全部关闭(引用计数为0):进程异常终止(收到SIGPIPE信号)
            - 读端没有全部关闭:
              - 管道已满:write阻塞
              - 管道未满:write将数据写入,并返回实际写入的字节数
          - 设置管道非阻塞:
            ```C++
            int flags = fcntl(fd[0], F_GETFL); // 获取读端原来的flag
            flags = flags|O_NOBLOCK; //添加非阻塞标志
            fcntl(fd[0], F_SETFL, flags); // 设置读端为非阻塞
            ```
      - 一般不会双向传递数据,会出现问题 

  - 查看管道缓冲大小:
    - 命令:ulimit -a
    - 函数:long fpathconf(int fd, int name);
      - 作用:获取文件配置的一些值
      - 参数:
        - fd:文件描述符
        - name:配置选项
          - _PC_PIPE_BUF:管道的大小


### 有名管道
- 匿名管道没有名字,只能用于亲缘关系的进程间通信
- 有名管道:FIFO, 不同于匿名管道,其有一个路径名与之关联,以FIFO的文件形式存在于文件系统中,打开方式与普通文件一样,使得不具有亲缘关系的进程都能访问
- 一旦打开FIFO,使用同匿名管道相同,并且从管道中读取数据的顺序和写入数据是一样的(FIFO名字的由来,先入先出).
- 有名管道(FIFO)与匿名管道的区别:
  - FIFO在文件系统中作为一个特殊的文件存在,但FIFO中的内容却存放在内存中(有文件实体,但是文件里没有内容)
  - 当使用FIFO的进程退出后,FIFO文件将继续保存在文件系统中以便以后使用
  - FIFO有名字,不相关的进程可以通过打开有名管道进行通信

- 创建有名管道:
  - 命令:mkfifo 名字
  - 系统调用:
    - int mkfifo(const char* pathname, mode_t mode);
      - 参数:
        - pathname:管道名称和路径
        - mode:文件的权限,和open一样,需要&~umask才是最终的权限
      - 返回值:
        - 成功:0
        - 失败:-1,设置errno
      - 注意:
        - 打开管道一般为只写或只读
          - 以只读打开的管道的进程会被阻塞(open的时候就阻塞),知道另一个进程以只写打开管道
          - 以只写打开的管道的进程会被阻塞(open的时候就阻塞),知道另一个进程以只读打开管道
            - 如果以只写方式打开管道, 如果不在open的地方阻塞, 那么如果执行到后面进行write, 而此时没有进程去读, 我就会收到SIGPIPE信号进而终止进程. 如果线运行read.c同理. 毕竟不管read.c还是write.c, 总要有一个先打开, 先打开的那个必须阻塞在open处, 以先打开写的进程为例, 必须阻塞在open处直到出现另一个进程以O_RDONLY或O_RDWR打开此管道, 我才能解除阻塞,不同的是,匿名管道在创建时就打开两端
          - 读管道:
            - 管道中有数据:read返回实际读到的字节数
            - 管道中无数据:             
              - 写端全部关闭(引用计数为0):read返回0(相当于读到文件末尾)
              - 写端没有完全关闭:read阻塞
          - 写管道:
            - 读端全部关闭(引用计数为0):进程异常终止(收到SIGPIPE信号)
            - 读端没有全部关闭:
              - 管道已满:write阻塞
              - 管道未满:write将数据写入,并返回实际写入的字节数


### 内存映射(memory-mapped I/O)

- 将磁盘文件映射到内存,用户通过修改内存就能修改磁盘文件
- 用于进程通信是非阻塞的
- 系统调用:
  - void* mmap(void* addr, size_t length, int port, int flags, int fd, off_t, offset);
    - 作用:将一个文件或者设备的数据映射到内存中
    - 参数:
      - addr:NULL,由内核指定映射的内存地址
      - length:要映射的数据的长度
        - 获取文件的长度:stat lseek
      - prot:对申请的内存映射区的操作权限
        - PROT_EXEC:可执行权限
        - PROT_READ:读权限
        - PROT_WRITE:写权限(要想有写权限必须要有读权限)
        - PROT_NONE:没有权限
      - flags:
        - MAP_SHARED:映射区的数据会自动和磁盘文件进行同步,进程间通信必须要有这个参数
        - MAP_PRIVATE:不同步,映射区的数据改变,对原来的文件不会产生影响
      - fd:需要映射的文件的描述符
        - 通过open得到,open的是一个磁盘文件,文件大小不能为0,且open指定的权限不能和prot参数有冲突,prot的权限小于等于open的权限
      - offset:偏移量,一般不用,必须指定是4k(4*1024)的整数倍,0表示不偏移
    - 返回值: 
      - 成功:返回创建的内存的首地址
      - 失败:返回MAP_FAILED(void* (-1)),并设置errno
  - int munmap(void* addr, size_t length);
    - 作用:释放内存映射
    - 参数:
      - addr:要释放的内存的首地址
      - length:要释放的内存的大小,要和mmap函数中的length参数值一样
    - 返回值:
      - 成功:返回0
      - 失败:返回-1,并设置errno
- 匿名映射:不需要文件实体进行内存映射,只能在父子进程之间进行通信
  - void* mmap(void* addr, size_t length, int port, int flags, int fd, off_t, offset);
    - flags: 
      - MAP_SHARED | MAP_ANONYMOUS: 匿名内存映射
    - fd: 设置为-1, 设置为其他的也会被忽略


### 信号
- 信号是linux进程间通信的最古老方式,又称为软件中断,是一种异步通信方式.
- 信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件
- 引发内核为进程产生信号的各类事件
  - 对于前台进程,用户可以通过输入特殊的终端字符来给他发送信号,例如ctrl+c
  - 硬件发生异常,检测到一个错误条件并通知内核,随即再由内核发送相应信号给相关进程.比如一条异常的机器语言指令(例如被0除, 或者引用了无法访问内存区域)
  - 系统状态变化,比如alarm定时器到期引起SIGALRM信号,进程执行的CPU时间超限,或者该进程的某个子进程退出
  - 运行kill命令或者调用kill函数
- 使用信号的目的:
  - 让进程知道已经发生的一个特定的事情
  - 强迫进程执行它自己代码中的信号处理程序
- 信号的特点
  - 简单(但底层实现不简单)
  - 不能携带大量信息
  - 满足某个特定条件才发送
  - 优先级比较高
- 查看系统信号 kill -l
  - 前31个信号为常规信号,其余为实时信号,常规信号不支持排队,最多只能记录一次,其余会被丢弃
  - 2.SIGINT: 按下ctrl+c,向正在运行中的由该终端启动的程序发出此信号 默认动作:终止进程
  - 3.SIGQUIT: 按下ctrl+\,向正在运行中的由该终端启动的程序发出此信号 默认动作:终止进程
  - 9.SIGKILL: 无条件终止进程,该信号不能被忽略,处理和阻塞 默认动作:终止进程,杀死任何进程(不包括僵尸进程)
  - 11.SIGSEGV:指示进程进行了无效的内存访问(段错误) 默认动作:终止进程并产生core文件
  - 13.SIGPIPE:向一个没有读端的管道写数据 默认动作:终止进程
  - 17.SIGCHLD:子进程结束时,父进程会收到这个信号 默认动作:忽略这个信号
  - 18.SIGCONT:如果进程已停止,则使其继续运行 默认动作:继续/忽略
  - 19.SIGSTOP:停止进程的执行,信号不能被忽略,处理和阻塞 默认动作:终止进程
- 信号的5种默认处理动作:
  - Term:终止进程
  - Ign:当前进程忽略掉这个信号
  - Core:终止进程,并生成一个core文件(保存程序异常退出的信息)
  - Stop:暂停当前进程
  - Cont:继续执行当前被暂停的进程
- 信号的几种状态:产生,未决,抵达
- 注意:SIGKILL,SIGSTOP信号不能被捕捉,阻塞或者忽略,只能执行默认动作

相关函数:
- int kill(pid_t pid, int sig);
  - 作用:给某个进程或进程组发送任何信号
  - 参数:
    - pid:进程号
      - 大于0:将信号发送给指定进程
      - 等于0:将信号发送给当前进程组
      - 等于-1:将信号发送给每一个有权限接受这个信号的进程
      - 小于-1:将信号发送个某个进程组(取绝对值)
    - sig:需要发送的信号的编号或者宏值,0表示不发送任何信号
- int raise(int sig);
  - 功能:给当前进程发送信号
    - 参数:
      - sig:需要发送的信号的编号或者宏值,0表示不发送任何信号
  - 返回值:
    - 0:成功
    - 非0:失败
- void abort(void);
  - 功能:发送SIGABRT信号给当前进程,杀死当前进程
- unsigned int alarm(unsigned int seconds);
  - 功能:设置定时器,函数调用,开始倒计时(函数不阻塞),当倒计时为0的时候,函数会给当前进程发送一个信号:SIGALARM(默认终止当前进程),每个进程有且只有一个定时器 
  - 参数:
    - seconds:倒计时的时长,单位:秒,如果参数为0,定时器无效
  - 返回值:
    - 之前有定时器:返回之前定时器倒计时剩余的时间
    - 之前没有定时器:返回0
  - 注意:与进程状态无关,采用自然计时,无论进程运不运行,都会计时
- int setitimer(int which, const struct itimerval *new_value, struct itimerval * old_value)
  - 作用:设置定时器, 可以替代alarm函数, 精度微妙级, 可以实现周期性定时
  - 参数:
    - which:定时器以什么时间计时
      - ITIMER_REAL:真是时间,时间到达,发送SIGALRM
      - ITIMER_VIRTUAL:用户时间,时间到达,发送SIGVTALRM
      - ITIMER_PROF:以该进程在用户态和内核态下所消耗的时间来计算,时间到达,发送SIGPROF
    - new_value:设置定时器的属性
    - old_value:记录上一次的时间参数,一般不适用,指定null
  - 返回值:
    - 成功:0
    - 失败:-1,并设置errno
- 信号捕捉:
  - sighandler_t signal(int signum, sighandler_t handler);
    - 功能:设置某个信号的捕捉行为
    - 参数:
      - signum:要捕捉的信号
      - handler:捕捉到的信号要如何处理
        - SIG_IGN:忽略信号
        - SIG_DFL:使用信号的默认行为
        - 回调函数:内核调用,程序员只负责写,捕捉到信号之后如何处理
          - void (*sighandler_t) (int)
      - 返回值:
        - 成功:返回上一次注册的信号处理函数的地址,第一次调用返回null
        - 失败:返回SIG_ERR,设置错误号


信号集:多个信号的集合,数据结构,sigset_t
- PCB中重要的信号集:
  - 阻塞信号集:
    - 阻塞:一种开关动作,组织信号被处理,不是阻止信号的产生,是为了让系统暂时保留信号待以后发送,一般情况下阻塞只是暂时的,是为了防止信号打断敏感操作
  - 未决信号集:一种状态,指的是从信号产生到信号被处理前的这一段时间
- 函数:对自定义的信号集操作
  - int sigempty(sigset_t * set);
    - 功能:清空信号集的中的数据,将信号集中的所有标志位置0
    - 参数:
      - set:传出参数,需要操作的信号集
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigfillset(sigset_t * set);
    - 功能:将信号集中的所有标志位置1
    - 参数:
      - set:传出参数,需要操作的信号集
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigaddset(sigset_t * set, int signum);
    - 功能:设置信号集中的某一个信号对应的标志位为1,表示阻塞这个信号
    - 参数:
      - set:传出参数,需要操作的信号集
      - signum:需要设置阻塞的那个信号
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigdelset(sigset_t * set, int signum);
    - 功能:设置信号集中的某一个信号对应的标志位为0,表示不阻塞这个信号
    - 参数:
      - set:传出参数,需要操作的信号集
      - signum:需要设置不阻塞的那个信号
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigismember(const sigset_t * set, int signum);
    - 功能:判断某个信号是否阻塞
    - 参数:
      - set:需要操作的信号集
      - signum:需要判断的那个信号
    - 返回值:
      - 1:signum被阻塞
      - 0:signum不被阻塞
      - -1:失败

- 函数:对系统信号集进行操作,系统调用
  - int sigprocmask(int how,const sigset_t* set, sigset* oldset);
    - 作用:将自定义信号集中的数据设置到内核中
    - 参数:
      - how:如何对内核阻塞信号集进行处理
        - SIG_BLOCK:将用户设置的阻塞信号集添加到内核中
        - SIG_UNBLOCK:根据用户设置的数据对内核中的数据接触阻塞
        - SIG-SETMASK:覆盖内核中原来的值
      - set:已经初始化好的用户信号集
      - oldset:保存设置之前的阻塞信号集,一般不使用
    - 返回值:
      - 0:成功
      - -1:失败,设置错误号:EFAULT,EINVAL
  - int sigpending(sigset_t* set);
    - 作用:获取内核中的未决信号集
    - 参数:set, 传出参数,,保存的是内核中的未决信号集

前后台指令:
- 将程序以后台的方式运行的命令:程序 &
- 将后台程序切换到前台的命令:fg


- 信号捕捉函数
  -  int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
     -  功能:检查或改变信号的处理
     -  参数:
        -  signum:需要捕捉的信号的编号或宏值
        -  act:捕捉到信号后的处理动作
        -  oldact:上一次信号捕捉的相关设置,一般不适用
        -  ```c++
            struct sigaction {
               void     (*sa_handler)(int); //函数指针,信号捕捉之后的处理函数,sa_flags=0
               void     (*sa_sigaction)(int, siginfo_t *, void *);//不常用, sa_flags=1
               sigset_t   sa_mask;//临时阻塞信号集
               int        sa_flags;//使用哪一个信号处理函数
               void     (*sa_restorer)(void);//已被废弃
           };
           ```
     - 返回值:
       - 成功:0
       - 失败:-1,并设置errno

SIGCHLD信号
- 产生条件:
  - 子进程终止时
  - 子进程接收到SIGSTOP信号停止时
  - 子进程处在停止态时,接收到SIGCONT后唤醒时
- 父进程接受该信号,默认忽略


### 共享内存
- 允许两个或多个进程共享物理内存的同一块区域(通常被成为段),由于一个共享内存段是一个进程用户空间的一部分,因此这种IPC机制无需内核介入.所有需要做的就是让一个进程将数据复制到共享内存中,并且这部分数据会对其他所有共享该共享内存的进程可用
  - 涉及到进程同步问题
- 与管道要求发送进程将数据从用户空间的缓冲区复制进内核内存和接受进程将数据从内核内存复制进用户空间缓冲区的做法相比,共享内存速度更快 
- 创建内存的使用步骤:
  - 调用shmget():创建一个新的共享内存段或取得一个既有共享内存段的标识符,返回后续调用中需要用到的共享内存标识符
  - 使用shmat():附上共享内存,使该段成为调用进程的虚拟内存的一部分.程序使用shmat()返回的addr值,它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针
  - 调用shmdt():分离共享内存段,在这个调用之后,进程就无法再引用这块共享内存,可选,进程终止时会自动完成这一步
  - 调用shmctl():来删除共享内存段,只有当当前所有附加内存段的进程都与之分离后内存段才会销毁,只有一个进程需要执行这一步.
- 函数:
  - int shmget(key_t key, size_t size, int shmflg);
    - 作用:创建一个新的共享内存段,或者获取一个既有的内存段标识,新创建的内存段中的数据都会被初始化为0
    - 参数:
      - key:key_t类型是一个整型,通过这个找到或者创建一个共享内存,一般使用16进制表示(非0值)
      - size:共享内存的大小,以页的大小创建
      - shmflag:属性
        - 访问权限:8进制数,例如0777(全权限)
        - 附加权限
          - 创建:IPC-CREAT
          - 判断共享内存是否存在: IPC_EXCL,需要和IPC_CREAT一起使用
      - 返回值:
        - 失败:-1,并设置错误号
        - 成功:>0,返回共享内存的引用的ID,后面操作共享内存都是通过这个值
    - void *shmat(int shmid, const void *shmaddr, int shmflg);
      - 作用:将共享内存和当前进程进行关联
      - 参数:
        - shmid:共享内存的标识(ID),由shmget返回值获取
        - shmaddr:申请的共享内存的起始地址,指定NULL,内核指定
        - shmflg:对共享内存的操作
          - 读:SHM-RDONLY,必须要有读权限
          - 读写:
        - 返回值:
          - 成功:返回共享内存的起始地址
          - 失败:(void*) -1
    - int shmdt(const void* shmaddr)
      - 作用:解除当前进程和共享内存的关联
      - 参数:
        - shmaddr:共享内存首地址
      - 返回值:成功0, 失败-1
    - int shmctl(int shmid, int cmd, struct shmid_ds* buf);
      - 作用:对共享内存操作(删除共享内存,共享内存才会消失,创建共享内存的进程销毁对共享内存没影响)
      - 参数:
        - shmid:共享内存的ID
        - cmd:要做的操作
          - IPC_STAT:获取共享内存当前的状态
          - IPC_SET:设置共享内存的状态
          - IPC_RMID:标记共享内存要被销毁
        - buf:需要设置或者获取的共享内存的属性信息
          - IPC_STAT:buf中存储数据
          - IPC_SET:buf中需要初始化数据,设置到内核中
          - IPC_RMID:没有用,设置为NULL
          - ```C++
                struct shmid_ds {
                struct ipc_perm shm_perm;    /* Ownership and permissions */
                size_t          shm_segsz;   /* Size of segment (bytes) */
                time_t          shm_atime;   /* Last attach time */
                time_t          shm_dtime;   /* Last detach time */
                time_t          shm_ctime;   /* Last change time */
                pid_t           shm_cpid;    /* PID of creator */
                pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
                shmatt_t        shm_nattch;  /* No. of current attaches */
                ...
            };
      - 返回值:
        - 成功:0
        - 失败:-1,并设置errno
    - key_t ftok(const char *pathname, int proj_id);
      - 作用:根据指定的路径名和int值,生成一个共享内存的key
      - 参数:
        - pathname:指定一个存在的可访问的路径
        - proj_id:int类型值,但是只会使用其中的一个字节:0-255,一般指定一个字符'a'
      - 返回值
        - 成功:返回指定的共享内存的key
        - 失败:-1,并设置errno
- 问题:
  - 1:操作系统如何知道一块共享内存被多少个进程关联
    - 共享内存维护了一个结构体struct shmid_ds,这个结构体中有一个成员shm_nattch,记录了关联的进程的个数
  - 2:可不可以用shmctl对共享内存进行多次删除
    - 可以的,shmctl只是标记删除共享内存(共享内存的key为0),只有当共享内存关联的进程数为0时,才被真正删除

- 共享内存和内存的映射的区别
  - 共享内存可以直接创建,内存映射需要磁盘文件(匿名映射除外)
  - 共享内存的效率更高
  - 共享内存中所有进程操作的是同一块内存,内存映射中每个进程在自己的虚拟地址空间中有一个独立的内存
  - 数据安全:
    - 进程突然退出:共享内存还在,内存映射区消失
    - 运行进程的电脑宕机:共享内存中的数据没有了,内存映射区的数据由于磁盘文件还在所以内存映射区的数据还在
  - 生命周期:内存映射区:进程退出,内存映射区销毁,共享内存还在(需要手动删除,且进程退出,会自动跟共享内存解除关联)


- 操作命令:
  - ipcs:打印
    - -a:打印当前系统中所有的进程间通信方式的信息
    - -m:打印出使用共享内存进行进程间通信的信息
    - -q:打印出使用消息队列进行进程间通信的信息
    - -s:打印出使用信号进行进程间通信的信息
  - ipcrm:移除(标记删除)
    - -M shmkey:移除用shmkey创建的共享内存段
    - -m shmid:移除用shmid标识的共享内存段
    - -Q msgkey:
    - -q msqid: 
    - -S semkey:
    - -s semid:

### 守护进程
- 终端:
  - UNIX系统中,用户通过终端登录后得到一个shell进程,这个终端成为shell进程的控制终端,进程中,控制终端是保存在PCB中的信息,而fork()会复制PCB中的信息,因此由shell进程启动的其他进程的控制终端也是这个终端
  - 默认情况下(没有重定向), 每个进程的标准输入,输出和错误都是指向控制终端,进程从标准输入读也就是读用户的键盘输入,进程往标准输出或错误写也是输出到显示器上
  - 在控制终端可以输入特殊的控制字符给前台进程发送信号,例如ctrl+c
- 进程组:
  - 一组相关进程的集合,会话是一组相关进程组的集合.进程组会话是为支持hsell作业控制而定义的抽象概念,用户通过shell能够交互式地在前台或后台运行命令.
  - 进程组由一个或多个共性同一进程组标识符(PGID)的进程组成,一个进程组拥有一个进程组首进程,首进程是创建该组的进程,其进程ID为该组的ID,新进程会继承其父进程所属的进程组ID
  - 进程组的生命周期:开始于首进程创建组的时刻,结束于最后一个成员进程退出组的时刻(一个进程可能会因为终止而退出进程组,也可能因为加入另一个进程组而退出)
- 会话:
  - 一组*进程组的集合*,会话首进程是创建该新会话的进程,其进程ID会成为会话ID,新进程会继承其父进程的会话ID
  - 一个会话中的所有进程共享单个控制终端,控制终端会在会话首进程首次打开一个终端设备时被建立.一个终端最多可能成为一个会话的控制终端
  - 在任一时刻,会话中的其中一个进程组会成为终端的前台进程组,其他进程组会成为后台进程组,只有前台进程组的进程才能从控制终端中读取输入,当用户在控制终端输入终端字符生成信号时,该信号会被发送到前台进程组的所有成员
  - 当控制终端的连接建立起来后,会话的首进程会成为该终端的控制进程
- 函数:
  - pid_t getpgrp(void);获取当前进程组
  - pid_t getpgid(pid_t pid);获取指定进程的进程组
  - int setpgid(pid_t pid, pid_t pgid); 设置进程的进程组
  - pid_t getsid(pid_t pid);获取指定进程的会话id
  - pid_t setsid(void);设置会话的id
- 守护进程(Daemon Process),也称精灵进程,是linux中的后台服务进程,是一个生存期较长的进程,通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件,一般采用以d结尾的名字
  - 特点:
    - 生命周期很长:守护进程会在系统启动时创建并一直运行直到系统关闭
    - 在后台运行并且不拥有控制终端,确保可内核永远不会为守护进程自动生成任何控制信号以及终端相关信号
  - linux的大多数服务器就是用守护进程实现的,例如internet服务器inetd,web服务器httpd等.
  - 守护进程的创建步骤:
    - 执行一个fork(),之后父进程退出,子进程继续执行
    - 子进程调用setsid()开启一个新的会话(脱离原来的控制终端)
    - 清除进程的umask保证守护进程创建文件和目录是拥有所需的权限
    - 修改进程的当前工作目录,通常会改为根目录
    - 关闭守护进程从父进程继承来的所有打开的文件描述符
    - 关闭了文件描述符0,1,2之后,守护进程通常会打开/dev/null,并使用dup2()使所有描述符指向这个设备
    - 核心业务逻辑