# 编译

 C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接。

预编译：`g++ 源代码文件（.cpp） -E -o 预编译文件（.i） `
这个过程主要的处理操作如下：
（1） 将所有的#define删除，并且展开所有的宏定义
（2） 处理所有的条件预编译指令，如#if、#ifdef
（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
（4） 过滤所有的注释
（5） 添加行号和文件名标识。

编译：`g++ 预编译文件（.i） -S -o 编译文件（.s） `  
这个过程主要的处理操作如下：
（1） 词法分析：将源代码的字符序列分割成一系列的记号。
（2） 语法分析：对记号进行语法分析，产生语法树。
（3） 语义分析：判断表达式是否有意义。
（4） 代码优化：
（5） 目标代码生成：生成汇编代码。
（6） 目标代码优化：

汇编：`g++ 编译文件（.s） -c -o 目标文件（.o） `  
这个过程主要是将汇编代码转变成机器可以执行的指令。

链接：
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

- 链接分为静态链接和动态链接。
  - 静态链接：是在链接的时候就已经把要调用的函数或者过程打包到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。
    - 静态库的制作：`ar rcs libxxx.a 多个目标文件（.o）` 
    - 静态库的链接：`g++ 目标文件（.o） -o 可执行文件 -I 头文件目录 -L 库文件目录 -l 库的名称（去掉lib和后缀）` 
  - 动态链接：是在链接的时候没有把调用的函数代码打包进去，而是在执行的过程中，再去找要链接的函数，动态库会被加载到内存当中，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。
    - ldd：列出程序执行依赖的动态库信息
    - 系统加载可执行代码时，能够知道其所依赖的库的名字，但还需要其绝对路径，此时需要系统的动态加载器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，，它先后搜索elf文件的DT_RPATH段--->环境变量LD_LIBRARY_PATH ---> /etc/ld.so.cache文件列表 ---> /lib/ , /usr/lib/ 目录找到库文件后将其加载到内存中国
    - 动态库的制作：
      - `g++ -c -fpic/-fPIC 多个源代码文件（.cpp） `生成多个目标文件（.o），得到与位置无关的代码
      - `g++ -shared 多个目标文件（.o） -o libxxx.so` 得到动态库
    - 动态库的链接： `g++ 目标文件（.o） -o 可执行文件 -I 头文件目录 -L 库文件目录 -l 库的名称（去掉lib和后缀）` 


Makefile文件：

- 规则： 目标...：依赖...
            命令（shell命令）
            ...
    - 目标：最终要生成的文件（伪目标除外）；依赖：生成目标所需要的文件或是目标；命令：通过执行命令对依赖操作生成目标（命令必须teb缩进）
    - 一个makefile文件里可以有一个或多个规则
- 变量：
  - 自定义变量：变量名=变量值 
  - 预定义变量：AR：归档维护程序名称，默认值为ar
              CC：C编译器的名称，默认值为cc
              CXX：C++编译器的名称，默认值为g++
              ￥@：目标的完整名名称
              ￥<：第一个依赖文件的名称
              $^:所有的依赖文件
  - 获取变量的值：$（变量名）
  - 通配符：% 用于模式匹配
  - 函数：$（函数名，函数参数）