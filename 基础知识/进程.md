# 进程

### 程序文件内容
- 二进制格式标识:描述可执行文件的元信息.(ELF可执行连接格式)
- 机器语言指令:对程序算法进行编码
- 程序入口地址:标识程序开始执行时的位置
- 数据:程序文件包含的变量初始值和字面量值
- 符号表及重定位表:描述程序中函数和变量的位置及名称,可以用于调试和运行时的符号解析(动态连接)
- 共享库和动态链接信息:程序文件所包含的一些字段,列出程序运行时需要的共享库.以及加载共享库的动态连接器的路径名
- 其他信息:描述如何创建进程

### 进程
- 进程是正在运行的程序的实例,操作系统执行的基本单元,传统的操作系统中,进程既是基本的分配单元,也是基本的执行单元
- 可以用一个程序来创建多个进程,进程是由内核定义的抽象实体,并为该实体分配用以执行程序的各项系统资源.从内核的角度,进程由用户内存空间和一系列内核数据结构组成
  - 用户内存空间包含了程序代码及代码使用的变量
  - 内核数据结构用于维护进程的状态信息
    - 与进程相关的标识号
    - 虚拟内存表
    - 打开文件的描述表
    - 信号传递及处理的有关信息
    - 进程资源的使用及限制
    - 当前工作目录
    - 其他信息

### 进程控制块
 PCB 在linux下是task_struct结构体
 主要内容:
- 进程id:系统中每个进程有唯一的id,用pid_t类型表示(一个非负整数)
- 进程状态:就绪,运行,阻塞等
- 进程切换时需要保存和恢复的一些CPU寄存器
- 描述虚拟地址空间的信息
- 描述控制终端的信息
- 当前工作目录
- umask掩码
- 文件描述符表
- 和信号相关的信息
- 用户id和组id
- 回话和进程组
- 进程可以使用的资源上限

### 进程的状态转换
- 运行态:进程占有处理器正在运行
- 就绪态:进程具备运行条件,等待系统分配处理器以便运行.多个就绪态的进程被排成一个队列,成为就绪队列
- 阻塞态:又称为等待和睡眠态,进程不具备运行条件,正在等待某个事件完成

运行态--->就绪态(时间片用完了)
就绪态--->运行态(被调度运行)
运行态--->阻塞态(等待某件事)
阻塞态--->就绪态(等待的事情发生了)

### 进程相关命令
- 查看进程
  - ps aux/ajx
      - a:显示终端上的所有进程(包括其他用户的进程)
      - u:显示进程的详细信息
      - x:显示没有控制终端的进程
      - j:列出与作业相关的进程(进程组id,父进程id)
- 杀死进程
  - kill [-signal] pid
  
小技巧:后台运行可执行程序: 可执行文件 &

进程号:类型为pid_t(整型),范围:0~32767.进程号PID唯一,但是可以重用
- pid_t getpid(void)
父进程:任何进程(除init进程)都是由另一个进程创建的,该进程为被创建进程的父进程,对应父进程号PPID
- pid_t getppid(void)
进程组:进程组是一个或多个进程的集合.之间相互关联,进程组可以接受同一终端的各种信号,进程组号为PGID,默认情况下,当前的进程号会当做当前的进程组号
- pid_t getpgid(void)

### 进程调度策略 (查一下)

### 进程的创建

- pid_t fork(void)
  - 作用:用于创建子进程
  - 返回值:会返回两次(会被执行两次)
    - 在父进程中返回创建的子进程的pid,在子进程中返回0
    - 在父进程中返回-1,表示创建失败,并设置errno
      - 失败的原因:
        - 当前系统的进程数达到了上限,errno=EAGAIN
        - 系统内存不足,errno=ENOMEM


注意:fork()函数的两次返回值的实现
当一个进程调用了fork以后,系统会创建一个子进程.这个子进程和父进程不同的地方只有他的进程ID和父进程ID,其他的都是一样.就象父进程克隆 (clone)自己一样.当然创建两个一模一样的进程是没有意义的.为了区分父进程和子进程,我们必须跟踪fork的返回值. 当fork调用失败的时候(内存不足或者是用户的最大进程数已到)fork返回-1,否则fork的返回值有重要的作用.对于父进程fork返回子进程的 ID,而对于fork子进程返回0.我们就是根据这个返回值来区分父子进程的. 

这个进程目前执行到fork调用即将返回（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。父进程继续执行，操作系统对fork的实现，使这个调用在父进程中返回刚刚创建的子进程的pid（一个正整数），所以下面的if语句中pid<0, pid==0的两个分支都不会执行。所以输出i am the parent process... 
子进程在之后的某个时候得到调度，它的上下文被换入，占据 CPU，操作系统对fork的实现，使得子进程中fork调用返回0(函数的返回值是储存在寄存器eax中的,当fork返回时，新进程会返回0是因为在初始化任务结构时，将eax设置为0)。所以在这个进程中pid=0。这个进程继续执行的过程中，if语句中 pid<0不满足，但是pid= =0是true。所以输出i am the child process... 

在fork中，把子进程加入到可运行的队列中，由进程调度程序在适当的时机调度运行。也就是从此时开始，当前进程分裂为两个并发的进程。 *无论哪个进程被调度运行，都将继续执行fork函数的剩余代码*，执行结束后返回各自的值

Linux 的 fork() 使用是通过写时拷贝实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只有在写入时才会复制地址空间（重新开辟一块内存），从而使各个进程拥有自己的地址空间。即资源的复制只有在写入时才会进行，在此之前，只有以只读的方式进行。
fork() 之后的父子进程共享文件，此时的 fork() 产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。 

父子进程之间的关系:
区别:
- fork()函数的返回值
- pcb中的一些数据:
  - 当前进程的pid
  - 当前进程的pid ppid
  - 信号集
共同点:
- 某些状态下:子进程刚被创建出来,还没有执行任何的写数据操作
  - 用户区的数据
  - 文件描述符表
- 变量
  - 刚开始的时候是一样的,共享的,如果修改了数据,就不共享了
  - 读时共享(子进程被创建,两个进程),写时拷贝

- gdb调试多线程
  - 设置调试父进程或子进程:set fllow-fork-mode [parent(默认) | child]
  - 设置调试模式:set detach-on-fork [on | off]
    - 默认为on,表示调试当前进程时,其他进程继续运行,如果为off,调试当前进程时,其他进程被挂起
  - 查看调试的进程:info inferiors
  - 切换当前调试的进程:inferior id
  - 使进程脱离GDB调试:detech inferiors id

### exec函数族

- exec函数组的作用是根据指定的文件名找到可执行文件,并用它来取代调用进程的内容,即在调用进程内部执行一个可执行文件
- 一般用法:先执行fork创建子进程,用exec替换子进程的代码,让子进程去执行
- 执行成功不会返回,调用进程的实体(代码段,数据段,堆栈)都被新的内容取代,只留下进程ID等一些表面上的信息保持原样,看上去是旧的躯壳,却已经注入了新的灵魂,调用失败才会返回-1,从原程序调用点接着往下执行
- C函数:
  - int execl(const char *path, const char *arg, ...);
    - 参数:
      - path:执行文件的路径
      - arg:执行可执行文件需要的参数列表
        - 第一个参数没什么作用,一般写上执行程序的名称
        - 第二个参数开始往后,是程序执行需要的参数列表,参数最后需要以null结束(哨兵)
    - 返回值:
      - 只有调用失败,才有返回值,返回-1,设置errno
  - int execlp(const char *file, const char *arg, ...);
    - 会到*环境变量*中查找指定的可执行文件,如果找到了就执行,找不到就执行不成功
    - 参数:
      - file:执行文件的名称
      - arg:执行可执行文件需要的参数列表
        - 第一个参数没什么作用,一般写上执行程序的名称
        - 第二个参数开始往后,是程序执行需要的参数列表,参数最后需要以null结束(哨兵)
    - 返回值:
      - 只有调用失败,才有返回值,返回-1,设置errno
  - int execle(const char *path, const char *arg, ...char *const envp[]);
    - envp:指定环境变量的字符串数组
  - int execv(const char *path, char *const argv[]);
      - argv:是需要的参数的一个字符串数组
  - int execvp(const char *file, char *const argv[]);
  - int execvpe(const char *file, char *const argv[],char *const envp[]);
  - int execve(const char* filename, char* const argv[], char* const envp[]);linux系统函数,以上几个函数都是此函数的封装
    - 总结: 
      - l:参数地址列表,以空指针结尾
      - v:存有各参数的字符串数组
      - p:按PATH环境变量制定的目录搜索可执行文件
      - e:存有环境变量字符串的数组


### 进程控制

- 进程退出:
  - void exit(int status)
    - 参数:
      - status:进程退出时的一个状态信息.父进程回收子进程资源时可以获取到
    - 作用:刷新IO缓冲,关闭文件描述符,然后调用_exit()系统调用,终止进程运行
  - void _exit(int status) linux系统函数

- 孤儿进程 (orphan)
  - 父进程运行结束,但子进程还在运行,称为孤儿进程
  - 每当出现一个孤儿进程,内核就把孤儿进程的父进程设置为init,init进程循环执行wait()等待已经退出的子进程.init进程会处理孤儿进程的善后工作
  - 孤儿进程不会有什么危害

- 僵尸进程 (zombie)
  - 每个进程结束后会释放自己的地址空间的用户区数据,内核区的PCB没有办法自己释放掉
  - 进程终止时,父进程尚未回收,子进程残留资源(PCB)在内核中,变成僵尸进程
  - 僵尸进程不能被kill -9 杀死
  - 导致的问题:父进程不调用wait()或waitpid()的话,那么保留的那段信息就不会释放,其进程号一直被占用,系统所能使用的进程号是有限的,如果有大量的僵尸进程,会导致系统由于没有可用的进程号而不能产生新的进程
  - 一种终端解决方法:杀死父进程,让init接管僵尸进程,从而对资源进行释放

### 进程回收
- 进程退出时,内核会释放该进程的所有资源,包括打开的文件,占用的内存等,但是仍为其保留一定信息(进程号,退出状态,运行时间等)
- 父进程可以通过调用wait()或waitpid()得到它的退出状态同时彻底清楚这个进程
  - pid_t wait(int * wstatus):阻塞
    - 作用:等待任意一个子进程的状态的改变,如果一个子进程结束了,回收子进程资源
    - 参数:
      - wstatus:进程退出时的状态信息,传入的是一个int类型的地址,传出参数.
    - 返回值:
      - 成功:返回被回收的子进程的pid
      - 失败:返回-1(所有的子进程结束了,或调用函数失败)
  - pid_t waitpid(pid_t pid , int* wstatus, int options):可以设置不阻塞,还可以指定等待哪个进程结束
    - 作用:回收指定进程号的子进程,可以设置是否阻塞
    - 参数:
      - pid: 
        - 大于0:某个进程的pid
        - 等于0:回收当前进程组的所有子进程
        - 等于-1:回收所有子进程,相当于wait()
        - 小于-1:回收某个进程组(组id=绝对值)的子进程
      - options:
        - 0:阻塞
        - WNOHANG:非阻塞
    - 返回值:
      - 大于0:返回子进程的pid
      - 等于0:非阻塞的情况下才有可能返回0(options=WNOHANG),表示还有子进程没有退出
      - -1:错误或者没有子进程了
- 一次wait或waitpid调用只能清理一个子进程
  