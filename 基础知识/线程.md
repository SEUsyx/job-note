# 线程 thread


### 基础概念
- 并发:一台咖啡机一队人轮流去取咖啡
- 并行:两台咖啡机两队人轮流去取咖啡(需要多核)
与进程类似,线程是允许应用程序并发执行多个任务的一种机制.一个进程可以包含多个线程,同一个程序中的所有线程均会独立执行自己的程序,且共享同一份全局内存区域  
注:传统意义上的UNIX进程只是多线程程序的一个特例,改进程只包含一个线程
- 进程是CPU分配资源的最小单位,线程是操作系统调度执行的最小单位
- 线程是轻量级的进程(LWP: light weight process), 在linux环境下线程的本质仍然是进程
- 查看指定进程的LWP号: ps -Lf 进程号

### 线程和进程间的区别
- 进程间的信息难以共享.父子进程只共享了只读代码段,并未共享内存
- 调用fork()来创建进程的代价相对较高,即使使用写时复制技术,仍然需要复制内存页表和文件描述符之类的多种进程属性
- 线程之间能方便,快速的共享信息,只需将数据复制到共享(全局或堆)变量中即可
- 创建线程比创建进程通常要快10倍以上,线程间是共享虚拟地址空间的,无需采用写时复制,也无需复制页表

### 线程之间共享和非共享的资源
- 共享资源
    - 进程ID和父进程ID
    - 进程组ID合会话ID
    - 用户ID和用户组ID
    - 文件描述符表
    - 信号处置
    - 文件系统相关信息:文件权限掩码(umask),当前工作目录
    - 虚拟地址空间(栈,代码段除外)
- 非共享资源
    - 线程ID
    - 信号掩码
    - 线程特有数据
    - error变量
    - 实时调度策略和优先级
    - 栈,本地变量和函数的调用链接信息

### 线程相关函数
- int pthread_create(pthread_t *thread,const pthread_attr_t* attr, void* (*start_routine)(void*),void* arg);
    - 功能:创建一个子线程
    - 参数:
        - thread: 传出参数,指向线程的ID的指针
        - attr: 设置线程的属性,一般使用默认值(NULL)
        - start_routine:函数指针,子线程需要处理的逻辑代码
        - arg:给第三个参数用,传参
    - 返回值:
        - 成功:0
        - 失败:返回错误号errnum,和之前的errno不一样(不能使用perrno,使用char* strerror(int errnum))

- void pthread_exit(void  * retval);
    - 功能:终止一个线程,在哪个线程调用就表示终止哪个线程,pthread_exit后面的代码不会执行.
    - 参数:
        - retval:需要传递一个指针,作为一个返回值,可以在pthread_join()中获取到

- pthread_t pthread_self();
    - 功能:返回线程的ID
    - 返回值:线程的ID

- int pthread_equal(pthread_t t1, pthread_t t2)
    - 功能:比较两个线程的ID是否相等(不同的操作系统pthread_t的类型实现不一样,有的是长整型,有的是结构体)

- int pthread_join(pthread_t thread, void **retval);
    - 功能: 和一个已经终止的线程进行连接,回收子线程的资源
        - 阻塞函数,调用一次只能回收一个子线程,一般在主线程中使用
    - 参数:
        - thread:需要回收的子线程的ID
        - retval:接受子线程退出时的返回值
            - 二级指针的原因:
            ```c++
                //传参的正确形式:
                void *ret;
                pthread_join(thread, &ret);//传进去ret指针的地址

                //pthread_join中的一句代码
                (*retval)= arg //等价于ret = arg,即将pthread_exit的返回值(arg,是一个地址)赋给ret,这样就完成了ret和arg同时指向同一个变量!!!

                //总结,为了修改ret的值,必须传递指向它的指针(否则就是值传递,无法修改ret的值)
            ```
    - 返回值:
        - 成功:0
        - 失败:非0,返回错误号

- int pthread_detach(pthread_t thread);
    - 功能:分离一个线程,当一个线程被标记为分离时,在其终止时资源会自动回收
        - 不能多次分离,会产生不可预料的行为
        - 不能去连接已经分离的线程,会报错
    - 参数:
        - thread:需要分离的线程的ID
    - 返回值:
        - 成功:0
        - 失败:非零的错误号

- int pthread_cancel(pthread_t thread);
    - 功能:取消线程,让线程终止,线程并不是立即取消,而是执行到一个取消点(系统规定好的一些系统调用,可以粗略的理解为从用户区到内核区的切换)时才会取消
    - 参数:
        - thread:要取消的线程的ID
    - 返回值:
        - 成功:0
        - 失败:错误号

- 线程属性:
    - int pthread_attr_init(pthread_attr_t * attr);
        - 初始化属性变量
    - int pthread_attr_destroy(pthread_attr_t* attr);
        - 释放
    - int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate);
        - 获取线程分离状态属性
        - 参数:
            - attr:线程属性
            - detachstate:分离属性
                - PTHREAD_CREATE_DETACHED:要分离
                - PTHREAD_CREATE_JOINABLE:要加入,不分离(默认)
    - int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate);
        - 设置线程分离状态属性

### 线程同步
- 线程的优势在于能够通过全局变量来共享资源,但是是有代价的,必须保证多个线程不会同时修改同一变量,或者某一线程不会读取其他线程修改的变量
- 临界区是指访问某一共享资源的代码片段,并且这段代码的执行应为原子操作,即同时访问同一共享资源的其他线程不应该终止该片段的执行
- 线程同步:即当有一个线程正在对内存进行操作时,其他线程都不可以对这个内存地址进行操作,直到线程完成操作,其他线程才能对该内存地址进行操作,其他线程处于等待状态,降低了线程并发的效率,但是为了保证数据的安全时必须的

- 互斥量(mutex, mutual exclusion)
    - 确保同时仅有一个线程可以访问某项共享资源
    - 互斥量的两种状态:已锁定(locked)和未锁定(unlocked),任何时候只有一个线程可以锁定该互斥量,试图对已锁定的某一互斥量再次加锁,将可能阻塞线程或者失败(取决于加锁时的使用方法)
    - 一旦线程锁定互斥量,随机成为该互斥量的所有者,只有所有者才能给互斥量解锁
    - 使用流程:
        - 锁定互斥量
        - 访问共享资源
        - 解锁互斥量
    - 函数:
        - 互斥量的类型:pthread_mutex_t
        - int pthread_mutex_init(pthread_mutex_t* restrict mutex, pthread_mutexattr_t * restrict attr)
         - 作用:初始化互斥量
         - 参数:
            - mutex:需要初始化的互斥量变量
            - attr:互斥量相关的属性
                - restrict: C语言的修饰符,被修饰的指针不能由其他指针进行操作
        - int pthread_mutex_destroy(pthread_mutex_t* mutex);
            - 作用:释放互斥量资源
        - int pthread_mutex_lock(pthread_mutex_t *mutex);
            - 作用:加锁,阻塞函数(如果有其他线程加锁了,只能阻塞等待)
        - int pthread_mutex_trylock(pthread_mutex_t *mutex);
            - 作用:尝试加锁,如果加锁失败,不会阻塞,会直接返回
        - int pthread_mutex_unlock(pthread_mutex_t *mutex);
            - 作用:解锁
- 死锁
    - 有时一个线程需要访问两个或更多不同的共享资源,而每个共享资源又都由不同的互斥量管理,当超过一个线程加锁同一组互斥量时,就有可能发生死锁.
    - 两个或两个以上的进程在执行过程中,因争夺共享资源而造成一种互相等待的现象,若无外力作用,他们都将无法推进下去,此时系统处于死锁状态
    - 死锁的几种场景
        - 忘记释放锁
        - 重复加锁
        - 多线程多锁,抢占锁资源

- 读写锁
    - 当有一个线程已经持有互斥锁时,互斥锁将所有试图进入临界区的线程都阻塞.但是如果当前持有互斥锁的线程只是想要读访问共享资源,而同时有其它几个线程也想读取这个共享资源,但是由于互斥锁的排他性,其它所有线程都无法获取锁,也就无法读访问共享资源,但实际上多个线程同时读访问共享资源并不会导致问题
    - 对数据的读写操作中,更多的是读操作,写操作比较少,例如数据库的读写应用.为了满足当前能够允许多个读出,但只允许一个写入的需求,线程提供了读写锁来实现.
    - 读写锁的特点:
        - 如果有其它线程读数据,则允许其它线程执行读操作,但不允许写操作
        - 如果有其它线程写数据,则其它线程都不允许读写操作
        - 写是独占的,写的优先级高
    - 读写锁的类型:pthread_rwlock_t
    - 函数:
        - int pthread_rwlock_init(pthread_rwlock_t* restrict rwlock, pthread_rwlock_t * restrict attr)
         - 作用:初始化读写锁
         - 参数:
            - rwlock:读写锁变量
            - attr:读写锁相关的属性
                - restrict: C语言的修饰符,被修饰的指针不能由其他指针进行操作
        - int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
            - 作用:释放读写锁资源
        - int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
            - 作用:加读锁
        - int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);
            - 作用:尝试加读锁
        - int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
            - 作用:加写锁
        - int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock);
            - 作用:尝试加写锁       
        - int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
            - 作用:解锁

- 条件变量
    - 条件变量类型:pthread_cond_t
    - int pthread_cond_init(pthread_cond_t* restrict cond, const pthread_condattr_t* restrict attr);
        - 作用:初始化条件变量
    - int pthread_cond_destroy(pthread_cond_t* cond);
        - 作用:销毁条件变量
    - int pthread_cond_wait(pthread_cond_t * restrict cond, pthread_mutex_t* restrict mutex);
        - 作用:等待,阻塞函数
        - 参数:
            - cond:条件变量
            - mutex:等待的时候释放的锁,防止产生死锁,不阻塞继续向下执行时会加锁
    - int pthread_cond_timedwait(pthread_cond_t* restrict abstime,pthread_mutex_t* restrict mutex,const struct timespec* restrict abstime);
        - 作用:以固定时间等待,调用该函数会阻塞直到指定的时间结束
    - int pthread_cond_signal(pthread_cond_t* cond);
        - 作用:通知,唤醒一个或多个等待线程
    - int pthread_cond_broadcast(pthread_cond_t* cond);
        - 作用:唤醒所有的等待线程

- 信号量
    - 信号量的类型 sem_t
    - 函数
        - int sem_init(sem_t* sem, int pshared, unsigned int value);
            - 作用:初始化信号量
            - 参数:
                - sem:信号量
                - pshared:代表信号量是用在进程还是线程之间
                    - 0:线程之间
                    - 非0:进程之间
                - value:信号量里的值
        - int sem_destroy(sem_t* sem);
            - 作用:释放信号量资源
        - int sem_wait(sem_t* sem);
            - 作用:使得信号量里的值(value)减一,当信号量为0时阻塞
        - int sem_trywait(sem_t* sem);
            - 作用:等待信号量,非阻塞函数
        - int sem_timedwait(sem_t* sem, const struct timespec *abs_timeout);
            - 作用:以指定时间等待信号量,阻塞函数直到等待时间耗尽
        - int sem_post(sem_t *sem);
            - 作用:使得信号量里的值(value)加一
        - int sem_getvalue(sem_t *sem, int *sval);
            - 作用:获取信号量里的值
        