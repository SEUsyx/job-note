# 信号

- 信号是linux进程间通信的最古老方式,又称为软件中断,是一种异步通信方式.
- 信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件
- 引发内核为进程产生信号的各类事件
  - 对于前台进程,用户可以通过输入特殊的终端字符来给他发送信号,例如ctrl+c
  - 硬件发生异常,检测到一个错误条件并通知内核,随即再由内核发送相应信号给相关进程.比如一条异常的机器语言指令(例如被0除, 或者引用了无法访问内存区域)
  - 系统状态变化,比如alarm定时器到期引起SIGALRM信号,进程执行的CPU时间超限,或者该进程的某个子进程退出
  - 运行kill命令或者调用kill函数
- 使用信号的目的:
  - 让进程知道已经发生的一个特定的事情
  - 强迫进程执行它自己代码中的信号处理程序
- 信号的特点
  - 简单(但底层实现不简单)
  - 不能携带大量信息
  - 满足某个特定条件才发送
  - 优先级比较高
- 查看系统信号 kill -l
  - 前31个信号为常规信号,其余为实时信号,常规信号不支持排队,最多只能记录一次,其余会被丢弃
  - 2.SIGINT: 按下ctrl+c,向正在运行中的由该终端启动的程序发出此信号 默认动作:终止进程
  - 3.SIGQUIT: 按下ctrl+\,向正在运行中的由该终端启动的程序发出此信号 默认动作:终止进程
  - 9.SIGKILL: 无条件终止进程,该信号不能被忽略,处理和阻塞 默认动作:终止进程,杀死任何进程(不包括僵尸进程)
  - 11.SIGSEGV:指示进程进行了无效的内存访问(段错误) 默认动作:终止进程并产生core文件
  - 13.SIGPIPE:向一个没有读端的管道写数据 默认动作:终止进程
  - 17.SIGCHLD:子进程结束时,父进程会收到这个信号 默认动作:忽略这个信号
  - 18.SIGCONT:如果进程已停止,则使其继续运行 默认动作:继续/忽略
  - 19.SIGSTOP:停止进程的执行,信号不能被忽略,处理和阻塞 默认动作:终止进程
- 信号的5种默认处理动作:
  - Term:终止进程
  - Ign:当前进程忽略掉这个信号
  - Core:终止进程,并生成一个core文件(保存程序异常退出的信息)
  - Stop:暂停当前进程
  - Cont:继续执行当前被暂停的进程
- 信号的几种状态:产生,未决,抵达
- 注意:SIGKILL,SIGSTOP信号不能被捕捉,阻塞或者忽略,只能执行默认动作

### 相关函数
- int kill(pid_t pid, int sig);
  - 作用:给某个进程或进程组发送任何信号
  - 参数:
    - pid:进程号
      - 大于0:将信号发送给指定进程
      - 等于0:将信号发送给当前进程组
      - 等于-1:将信号发送给每一个有权限接受这个信号的进程
      - 小于-1:将信号发送个某个进程组(取绝对值)
    - sig:需要发送的信号的编号或者宏值,0表示不发送任何信号
- int raise(int sig);
  - 功能:给当前进程发送信号
    - 参数:
      - sig:需要发送的信号的编号或者宏值,0表示不发送任何信号
  - 返回值:
    - 0:成功
    - 非0:失败
- void abort(void);
  - 功能:发送SIGABRT信号给当前进程,杀死当前进程
- unsigned int alarm(unsigned int seconds);
  - 功能:设置定时器,函数调用,开始倒计时(函数不阻塞),当倒计时为0的时候,函数会给当前进程发送一个信号:SIGALARM(默认终止当前进程),每个进程有且只有一个定时器 
  - 参数:
    - seconds:倒计时的时长,单位:秒,如果参数为0,定时器无效
  - 返回值:
    - 之前有定时器:返回之前定时器倒计时剩余的时间
    - 之前没有定时器:返回0
  - 注意:与进程状态无关,采用自然计时,无论进程运不运行,都会计时
- int setitimer(int which, const struct itimerval *new_value, struct itimerval * old_value)
  - 作用:设置定时器, 可以替代alarm函数, 精度微妙级, 可以实现周期性定时
  - 参数:
    - which:定时器以什么时间计时
      - ITIMER_REAL:真是时间,时间到达,发送SIGALRM
      - ITIMER_VIRTUAL:用户时间,时间到达,发送SIGVTALRM
      - ITIMER_PROF:以该进程在用户态和内核态下所消耗的时间来计算,时间到达,发送SIGPROF
    - new_value:设置定时器的属性
    - old_value:记录上一次的时间参数,一般不适用,指定null
  - 返回值:
    - 成功:0
    - 失败:-1,并设置errno
- 信号捕捉:
  - sighandler_t signal(int signum, sighandler_t handler);
    - 功能:设置某个信号的捕捉行为
    - 参数:
      - signum:要捕捉的信号
      - handler:捕捉到的信号要如何处理
        - SIG_IGN:忽略信号
        - SIG_DFL:使用信号的默认行为
        - 回调函数:内核调用,程序员只负责写,捕捉到信号之后如何处理
          - void (*sighandler_t) (int)
      - 返回值:
        - 成功:返回上一次注册的信号处理函数的地址,第一次调用返回null
        - 失败:返回SIG_ERR,设置错误号


### 信号集
多个信号的集合,数据结构,sigset_t
- PCB中重要的信号集:
  - 阻塞信号集:
    - 阻塞:一种开关动作,组织信号被处理,不是阻止信号的产生,是为了让系统暂时保留信号待以后发送,一般情况下阻塞只是暂时的,是为了防止信号打断敏感操作
  - 未决信号集:一种状态,指的是从信号产生到信号被处理前的这一段时间
- 函数:对自定义的信号集操作
  - int sigempty(sigset_t * set);
    - 功能:清空信号集的中的数据,将信号集中的所有标志位置0
    - 参数:
      - set:传出参数,需要操作的信号集
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigfillset(sigset_t * set);
    - 功能:将信号集中的所有标志位置1
    - 参数:
      - set:传出参数,需要操作的信号集
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigaddset(sigset_t * set, int signum);
    - 功能:设置信号集中的某一个信号对应的标志位为1,表示阻塞这个信号
    - 参数:
      - set:传出参数,需要操作的信号集
      - signum:需要设置阻塞的那个信号
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigdelset(sigset_t * set, int signum);
    - 功能:设置信号集中的某一个信号对应的标志位为0,表示不阻塞这个信号
    - 参数:
      - set:传出参数,需要操作的信号集
      - signum:需要设置不阻塞的那个信号
    - 返回值:
      - 成功:0
      - 失败:-1
  - int sigismember(const sigset_t * set, int signum);
    - 功能:判断某个信号是否阻塞
    - 参数:
      - set:需要操作的信号集
      - signum:需要判断的那个信号
    - 返回值:
      - 1:signum被阻塞
      - 0:signum不被阻塞
      - -1:失败

- 函数:对系统信号集进行操作,系统调用
  - int sigprocmask(int how,const sigset_t* set, sigset* oldset);
    - 作用:将自定义信号集中的数据设置到内核中
    - 参数:
      - how:如何对内核阻塞信号集进行处理
        - SIG_BLOCK:将用户设置的阻塞信号集添加到内核中
        - SIG_UNBLOCK:根据用户设置的数据对内核中的数据接触阻塞
        - SIG-SETMASK:覆盖内核中原来的值
      - set:已经初始化好的用户信号集
      - oldset:保存设置之前的阻塞信号集,一般不使用
    - 返回值:
      - 0:成功
      - -1:失败,设置错误号:EFAULT,EINVAL
  - int sigpending(sigset_t* set);
    - 作用:获取内核中的未决信号集
    - 参数:set, 传出参数,,保存的是内核中的未决信号集

前后台指令:
- 将程序以后台的方式运行的命令:程序 &
- 将后台程序切换到前台的命令:fg


- 信号捕捉函数
  -  int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);
     -  功能:检查或改变信号的处理
     -  参数:
        -  signum:需要捕捉的信号的编号或宏值
        -  act:捕捉到信号后的处理动作
        -  oldact:上一次信号捕捉的相关设置,一般不适用
        -  ```c++
            struct sigaction {
               void     (*sa_handler)(int); //函数指针,信号捕捉之后的处理函数,sa_flags=0
               void     (*sa_sigaction)(int, siginfo_t *, void *);//不常用, sa_flags=1
               sigset_t   sa_mask;//临时阻塞信号集
               int        sa_flags;//使用哪一个信号处理函数
               void     (*sa_restorer)(void);//已被废弃
           };
           ```
     - 返回值:
       - 成功:0
       - 失败:-1,并设置errno

SIGCHLD信号
- 产生条件:
  - 子进程终止时
  - 子进程接收到SIGSTOP信号停止时
  - 子进程处在停止态时,接收到SIGCONT后唤醒时
- 父进程接受该信号,默认忽略