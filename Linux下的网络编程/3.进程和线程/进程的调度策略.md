# 调度算法


非抢占式内核和抢占式内核: 
- 非抢占式内核: 让一个进程一直运行直至堵塞或者自动释放CPU，该进程不会被强制挂起。其结果是在中断产生时，如果没有更高优先级的进程等待计时到时，该进程会一直运行下去
- 抢占式内核: 抢占式中断会挑选一个进程，并让该进程运行某一个固定的最大值，如果在该时间段内进程仍然在运行，则该进程被挂起，调度程序选择另一个进程进行执行

| 抢占式调度                                 | 非抢占式调度                                   |
| :----------------------------------------- | :--------------------------------------------- |
| 在有限的时间内根据周期分配资源             | 资源被使用，然后由进程保留，直到被终止         |
| 该过程甚至可以在完成之前被中断             | 该过程直到其生命周期完成才被中断               |
| 由于在队列中插入了优先级过程，可能导致饥饿 | 当突发时间较长的进程占用系统时，可能会发生饥饿 |
| 维持队列和剩余时间需要存储开销             | 不需要此类开销                                 |

### 目标
所有系统：
- 公平：给每个进程公平的CPU份额
- 策略强制执行：看到所宣布的策略执行
- 平衡：保持系统的所有部分都忙碌

批处理系统：
- 吞吐量：每小时最大作业数
- 周转时间：从提交到终止间的最小时间
- CPU利用率：保持CPU始终忙碌
- 批处理一般运用在商业领域，用来处理薪水册、存货清单等。在批处理系统中，不会有用户不耐烦地在终端旁边等待一个短请求，因此其常用非抢占式算法

交互式系统：
- 相应时间：快速相应用户请求
- 均衡性：满足用户的期望
交互式：在交互式系统中，为了避免一个进程霸占CPU拒绝为其他用户服务，所以用的都是抢占式算法

实时系统：
- 满足截止时间：避免丢失数据
- 可预测性：在多媒体系统中避免品质降低
- 在实时操作系统中，抢占有时不是必须的，因为系统知道他们有可能会长时间得不到运行，所以会很快地完成各自的工作然后堵塞。实时系统和交互系统的差别是：实时系统只运行哪些用来推进现有应用程序的，而交互式系统则是通用的

### 具体调度算法
批处理系统:
- 先来先服务:FCFS
    - 最简单的非抢占式算法，基本上维持一个就绪进程的单一队列，有新作业到来时会插入到队列尾部。每次系统调用时从队列头部取作业进行运行，指导该作业完成
    - 优点：易于理解并且便于在程序中运用
    - 缺点：当存在一个需要占用较长CPU的进程存在时，会造成后边进程持续等待而无法执行，及时等待进程中存在只需要很少CPU时间即可完成的进程
- 最短作业优先:SJ(P)F
    - 是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
    - 缺点:
- 最短剩余作业优先
    - 使用该算法，调度程序总是选择运行剩余时间最短的那个作业。当新的进程到来时，如果新的程序比当前正在运行的程序完成所需更短的时间，则当前进程挂起，运行新的进程
交互系统:
- 轮转调度:时间片轮转算法(RR)
    - 轮转调度是一种最古老，最简单且最公平使用最广的算法。它为每一个进程分配一个时间段成为时间片,如果在该时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。如果该进程在时间片内堵塞或者结束，则CPU立即切换。时间片调度容易实现，调度程序只需要维护一张可运行程序的进程列表即可
- 优先级调度:
    - 轮转调度隐含的假设是所有进程同等重要，也就是所有进程的优先级相同。然后对于操作系统和用户会认为某些进程要比其他进程更为重要。因此调度算法调度时需要考虑一些外部因素。优先级调度的基本思想是为每一个进程赋予一个优先级，允许最高优先级的可运行程先运行。同时为了防止高优先级的程序一直占用CPU，调度程序可在每个时钟中断时降低当前进程的优先级，如果当前进的优先级低于次高优先级进程，则进行进程切换。一个可行的方法是，每个进程可以赋予一个允许运行的最大时间片，当这个时间片用完时，下一个次高优先级的进程获得机会运行
- 多级队列:
    - 多级队列的思想是将进程分为几个优先级类，当一个进程用完所分配的时间片后将会被移到下一类
    - 我们考虑一个需要100个时间片来进行连续计算的计算的进程。假如它最初被分配1个时间片，则时间片用完之后将其移到下一类，同时它将获得2个时间片，依次类推，接下来其将获得8、16、32和64个时间片。这样其通过7次进程切换就可以完成，如果是纯粹的时间片轮转算法则需要100此进程切换。并且随着优先级的不断下降，其可以将CPU让给运行时间较短的进程