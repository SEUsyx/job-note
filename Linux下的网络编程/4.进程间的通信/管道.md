# 管道(pipe)

### 匿名管道
- unix系统IPC的最古老的形式
- 管道符:|
- 特点:
  - 管道其实是一个在*内核内存*中维护的缓冲器,这个缓冲器的能力是有限的,不同的操作系统大小不一定相同
  - 管道拥有文件的特质:可以进行读操作,写操作,匿名管道没有文件实体,有名管道有文件实体,但不存储数据.可以按照操作文件的方式对管道进行操作
  - 一个管道是一个字节流,使用管道时不存在消息或消息边界的概念,从管道读取数据的进程可以读取任意大小的数据块,而不管写入进程的数据块的大小是多少
  - 通过管道传递的数据是顺序的,从管道中读取的字节顺序和他们被写入的顺序是完全一样的,环形队列
  - 管道中的数据传输方向是单向的,一端用于写入,一端用于读取,管道是半双工的
    - 单工:电视遥控器,只能向传输
    - 半双工:对讲机,可以双向传输,但是同一时刻只能单项传输
    - 双工:电话,可以双向同时传输
  - 管道读数据是一次性操作,数据一旦被读走,就从管道中被抛弃,释放空间以便写更多的数据
  - 匿名管道只能在具有公共祖先的进程(父子进程,兄弟进程,具有亲缘关系)之间使用
    - 原因:进程fork之后共享文件描述符表

- 系统调用
  - 创建匿名管道:int pipe(int pipefd[2]);
    - 功能:创建管道,用来进行IPC
    - 参数:
      - pipefd[2]:管道的两端,传出参数
        - pipefd[0]:管道的读端
        - pipefd[1]:管道的写端
    - 返回值:
        - 成功:0
        - 失败:-1
    - 注意:
      - 匿名管道只能在具有公共祖先的进程(父子进程,兄弟进程,具有亲缘关系)之间使用
      - 在fork之前创建管道
      - 管道默认是阻塞的:如果管道没有数据, read阻塞; 如果管道满了,write阻塞(不严谨)
        - 严谨说法,分为一下具体情况:
          - 读管道:
            - 管道中有数据:read返回实际读到的字节数
            - 管道中无数据:             
              - 写端全部关闭(引用计数为0):read返回0(相当于读到文件末尾)
              - 写端没有完全关闭:read阻塞
          - 写管道:
            - 读端全部关闭(引用计数为0):进程异常终止(收到SIGPIPE信号)
            - 读端没有全部关闭:
              - 管道已满:write阻塞
              - 管道未满:write将数据写入,并返回实际写入的字节数
          - 设置管道非阻塞:
            ```C++
            int flags = fcntl(fd[0], F_GETFL); // 获取读端原来的flag
            flags = flags|O_NOBLOCK; //添加非阻塞标志
            fcntl(fd[0], F_SETFL, flags); // 设置读端为非阻塞
            ```
      - 一般不会双向传递数据,会出现问题 

  - 查看管道缓冲大小:
    - 命令:ulimit -a
    - 函数:long fpathconf(int fd, int name);
      - 作用:获取文件配置的一些值
      - 参数:
        - fd:文件描述符
        - name:配置选项
          - _PC_PIPE_BUF:管道的大小


### 有名管道
- 匿名管道没有名字,只能用于亲缘关系的进程间通信
- 有名管道:FIFO, 不同于匿名管道,其有一个路径名与之关联,以FIFO的文件形式存在于文件系统中,打开方式与普通文件一样,使得不具有亲缘关系的进程都能访问
- 一旦打开FIFO,使用同匿名管道相同,并且从管道中读取数据的顺序和写入数据是一样的(FIFO名字的由来,先入先出).
- 有名管道(FIFO)与匿名管道的区别:
  - FIFO在文件系统中作为一个特殊的文件存在,但FIFO中的内容却存放在内存中(有文件实体,但是文件里没有内容)
  - 当使用FIFO的进程退出后,FIFO文件将继续保存在文件系统中以便以后使用
  - FIFO有名字,不相关的进程可以通过打开有名管道进行通信

- 创建有名管道:
  - 命令:mkfifo 名字
  - 系统调用:
    - int mkfifo(const char* pathname, mode_t mode);
      - 参数:
        - pathname:管道名称和路径
        - mode:文件的权限,和open一样,需要&~umask才是最终的权限
      - 返回值:
        - 成功:0
        - 失败:-1,设置errno
      - 注意:
        - 打开管道一般为只写或只读
          - 以只读打开的管道的进程会被阻塞(open的时候就阻塞),知道另一个进程以只写打开管道
          - 以只写打开的管道的进程会被阻塞(open的时候就阻塞),知道另一个进程以只读打开管道
            - 如果以只写方式打开管道, 如果不在open的地方阻塞, 那么如果执行到后面进行write, 而此时没有进程去读, 我就会收到SIGPIPE信号进而终止进程. 如果线运行read.c同理. 毕竟不管read.c还是write.c, 总要有一个先打开, 先打开的那个必须阻塞在open处, 以先打开写的进程为例, 必须阻塞在open处直到出现另一个进程以O_RDONLY或O_RDWR打开此管道, 我才能解除阻塞,不同的是,匿名管道在创建时就打开两端
          - 读管道:
            - 管道中有数据:read返回实际读到的字节数
            - 管道中无数据:             
              - 写端全部关闭(引用计数为0):read返回0(相当于读到文件末尾)
              - 写端没有完全关闭:read阻塞
          - 写管道:
            - 读端全部关闭(引用计数为0):进程异常终止(收到SIGPIPE信号)
            - 读端没有全部关闭:
              - 管道已满:write阻塞
              - 管道未满:write将数据写入,并返回实际写入的字节数