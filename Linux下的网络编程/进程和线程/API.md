# 进程相关API

### 进程创建
- pid_t fork(void)
  - 作用:用于创建子进程
  - 返回值:会返回两次(会被执行两次)
    - 在父进程中返回创建的子进程的pid,在子进程中返回0
    - 在父进程中返回-1,表示创建失败,并设置errno
      - 失败的原因:
        - 当前系统的进程数达到了上限,errno=EAGAIN
        - 系统内存不足,errno=ENOMEM


注意:fork()函数的两次返回值的实现
当一个进程调用了fork以后,系统会创建一个子进程.这个子进程和父进程不同的地方只有他的进程ID和父进程ID,其他的都是一样.就象父进程克隆 (clone)自己一样.当然创建两个一模一样的进程是没有意义的.为了区分父进程和子进程,我们必须跟踪fork的返回值. 当fork调用失败的时候(内存不足或者是用户的最大进程数已到)fork返回-1,否则fork的返回值有重要的作用.对于父进程fork返回子进程的 ID,而对于fork子进程返回0.我们就是根据这个返回值来区分父子进程的. 

这个进程目前执行到fork调用即将返回（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。父进程继续执行，操作系统对fork的实现，使这个调用在父进程中返回刚刚创建的子进程的pid（一个正整数），所以下面的if语句中pid<0, pid==0的两个分支都不会执行。所以输出i am the parent process... 
子进程在之后的某个时候得到调度，它的上下文被换入，占据 CPU，操作系统对fork的实现，使得子进程中fork调用返回0(函数的返回值是储存在寄存器eax中的,当fork返回时，新进程会返回0是因为在初始化任务结构时，将eax设置为0)。所以在这个进程中pid=0。这个进程继续执行的过程中，if语句中 pid<0不满足，但是pid= =0是true。所以输出i am the child process... 

在fork中，把子进程加入到可运行的队列中，由进程调度程序在适当的时机调度运行。也就是从此时开始，当前进程分裂为两个并发的进程。 *无论哪个进程被调度运行，都将继续执行fork函数的剩余代码*，执行结束后返回各自的值

Linux 的 fork() 使用是通过写时拷贝实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只有在写入时才会复制地址空间（重新开辟一块内存），从而使各个进程拥有自己的地址空间。即资源的复制只有在写入时才会进行，在此之前，只有以只读的方式进行。
fork() 之后的父子进程共享文件，此时的 fork() 产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。 

父子进程之间的关系:
区别:
- fork()函数的返回值
- pcb中的一些数据:
  - 当前进程的pid
  - 当前进程的pid ppid
  - 信号集
共同点:
- 某些状态下:子进程刚被创建出来,还没有执行任何的写数据操作
  - 用户区的数据
  - 文件描述符表
- 变量
  - 刚开始的时候是一样的,共享的,如果修改了数据,就不共享了
  - 读时共享(子进程被创建,两个进程),写时拷贝

- gdb调试多线程
  - 设置调试父进程或子进程:set fllow-fork-mode [parent(默认) | child]
  - 设置调试模式:set detach-on-fork [on | off]
    - 默认为on,表示调试当前进程时,其他进程继续运行,如果为off,调试当前进程时,其他进程被挂起
  - 查看调试的进程:info inferiors
  - 切换当前调试的进程:inferior id
  - 使进程脱离GDB调试:detech inferiors id

### 进程控制

- 进程退出:
  - void exit(int status)
    - 参数:
      - status:进程退出时的一个状态信息.父进程回收子进程资源时可以获取到
    - 作用:刷新IO缓冲,关闭文件描述符,然后调用_exit()系统调用,终止进程运行
  - void _exit(int status) linux系统函数

- 孤儿进程 (orphan)
  - 父进程运行结束,但子进程还在运行,称为孤儿进程
  - 每当出现一个孤儿进程,内核就把孤儿进程的父进程设置为init,init进程循环执行wait()等待已经退出的子进程.init进程会处理孤儿进程的善后工作
  - 孤儿进程不会有什么危害

- 僵尸进程 (zombie)
  - 每个进程结束后会释放自己的地址空间的用户区数据,内核区的PCB没有办法自己释放掉
  - 子进程终止时,父进程尚未回收,子进程残留资源(PCB)在内核中,变成僵尸进程(子进程比父进程终止的早)
  - 僵尸进程不能被kill -9 杀死
  - 导致的问题:父进程不调用wait()或waitpid()的话,那么保留的那段信息就不会释放,其进程号一直被占用,系统所能使用的进程号是有限的,如果有大量的僵尸进程,会导致系统由于没有可用的进程号而不能产生新的进程
  - 一种终端解决方法:杀死父进程,让init接管僵尸进程,从而对资源进行释放

### 进程回收
- 进程退出时,内核会释放该进程的所有资源,包括打开的文件,占用的内存等,但是仍为其保留一定信息(进程号,退出状态,运行时间等)
- 父进程可以通过调用wait()或waitpid()得到它的退出状态同时彻底清楚这个进程
  - pid_t wait(int * wstatus):阻塞
    - 作用:等待任意一个子进程的状态的改变,如果一个子进程结束了,回收子进程资源
    - 参数:
      - wstatus:进程退出时的状态信息,传入的是一个int类型的地址,传出参数.
    - 返回值:
      - 成功:返回被回收的子进程的pid
      - 失败:返回-1(所有的子进程结束了,或调用函数失败)
  - pid_t waitpid(pid_t pid , int* wstatus, int options):可以设置不阻塞,还可以指定等待哪个进程结束
    - 作用:回收指定进程号的子进程,可以设置是否阻塞
    - 参数:
      - pid: 
        - 大于0:某个进程的pid
        - 等于0:回收当前进程组的所有子进程
        - 等于-1:回收所有子进程,相当于wait()
        - 小于-1:回收某个进程组(组id=绝对值)的子进程
      - options:
        - 0:阻塞
        - WNOHANG:非阻塞
    - 返回值:
      - 大于0:返回子进程的pid
      - 等于0:非阻塞的情况下才有可能返回0(options=WNOHANG),表示还有子进程没有退出
      - -1:错误或者没有子进程了
- 一次wait或waitpid调用只能清理一个子进程