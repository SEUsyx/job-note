# C++ 11

### 变量存储  内存模型

c++管理数据内存的三种方式：自动存储、静态存储
c++11新增了第四种：线程存储（变量的持续性和整个线程一样）
![avatar](.\pictures/c++%20memory.png)

| 存储描述         | 持续性            | 作用域 | 链接性 | 如何声明                         | 限定符                                 |
| :--------------- | :---------------- | :----- | :----- | :------------------------------- | :------------------------------------- |
| 自动存储         | 自动              | 代码块 | 无     | 在代码块中                       | auto(c++ 11 不再支持)                  |
| 寄存器           | 自动              | 代码块 | 无     | 在代码块中                       | register                               |
| 静态，无链接性   | 静态              | 代码块 | 无     | 在代码块中，使用关键字static     | static                                 |
| 静态，内部链接性 | 静态              | 文件   | 内部   | 不在任何函数内，使用关键字static | static                                 |
| 静态，外部链接性 | 静态              | 文件   | 外部   | 不在任何函数内                   | extern（声明时可以省略，使用是必须有） |
| 动态存储         | 由new和delete控制 | 无     | 无     | 函数内外都可以声明               |

注：const的全局变量的链接性为内部，即外部不可调用，可使用extern关键字来覆盖默认的内部链接性变成外部链接性


### 存储说明符

- auto ：声明变量为自动变量
- register：声明变量为寄存器变量
- static：静态存储变量
- extern：外部链接性
- thread_local：线程变量
- mutable：可以修改const限定的结构中的变量
- volatile：不让编译器执行优化（例如发现几条语句中两次使用了某个变量，编译器不让程序查找这个值两次，会将这个值缓存到寄存器中，这中间可能导致变量的值发生变化）


## new和malloc的区别

- 申请内存的位置：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  - 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  - 堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  - 自由存储区不等于堆，如上所述，布局new（指定使用的位置，相关博客https://www.cnblogs.com/sunrunner/p/3716134.html）就可以不位于堆中。
- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。
而malloc则需要显式地指出所需内存的尺寸。
- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符；而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- malloc是面向内存的，你要开多大，就给你开多大，开了就不管了。new是面向对象的，根据你指定的数据类型来申请对应的空间，并且能够直接内部调用构造函数生成对象。



