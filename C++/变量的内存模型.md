# C++ 11

### 变量存储  内存模型

c++管理数据内存的三种方式：自动存储、静态存储
c++11新增了第四种：线程存储（变量的持续性和整个线程一样）
![avatar](.\pictures/c++%20memory.png)

| 存储描述         | 持续性            | 作用域 | 链接性 | 如何声明                         | 限定符                                 |
| :--------------- | :---------------- | :----- | :----- | :------------------------------- | :------------------------------------- |
| 自动存储         | 自动              | 代码块 | 无     | 在代码块中                       | auto(c++ 11 不再支持)                  |
| 寄存器           | 自动              | 代码块 | 无     | 在代码块中                       | register                               |
| 静态，无链接性   | 静态              | 代码块 | 无     | 在代码块中，使用关键字static     | static                                 |
| 静态，内部链接性 | 静态              | 文件   | 内部   | 不在任何函数内，使用关键字static | static                                 |
| 静态，外部链接性 | 静态              | 文件   | 外部   | 不在任何函数内                   | extern（声明时可以省略，使用是必须有） |
| 动态存储         | 由new和delete控制 | 无     | 无     | 函数内外都可以声明               |

注：const的全局变量的链接性为内部，即外部不可调用，可使用extern关键字来覆盖默认的内部链接性变成外部链接性


### 存储说明符

- auto ：声明变量为自动变量
- register：声明变量为寄存器变量
- static：静态存储变量
- extern：外部链接性
- thread_local：线程变量
- mutable：可以修改const限定的结构中的变量
- volatile：不让编译器执行优化（例如发现几条语句中两次使用了某个变量，编译器不让程序查找这个值两次，会将这个值缓存到寄存器中，这中间可能导致变量的值发生变化）  
一个volatile的例子：
```C++
const  int const_value = 100;
int * ptr = (int *)&const_value;  
*ptr = 200;
cout<<*ptr<<"  "<<const_value<<endl;
//结果输出为200，100，其实已经通过指针将const_value变量地址内的值已经变成了200，但是由于编译器的优化，将const类型的const_value放在编译器的符号表内，计算时编译器直接从表中取值，所以输出为100

const volatile int const_value = 100;
int * ptr = (int *)&const_value;  
*ptr = 200;
cout<<*ptr<<"  "<<const_value<<endl;
//结果为200，200， 编译器阻止了上述优化
```


## new和malloc的区别

- 申请内存的位置：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。
  - 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
  - 堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。
  - 自由存储区不等于堆，如上所述，布局new（即placement new，指定使用的位置，相关博客https://www.cnblogs.com/sunrunner/p/3716134.html）就可以不位于堆中。
- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符；而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- malloc是面向内存的，你要开多大，就给你开多大，开了就不管了。new是面向对象的，根据你指定的数据类型来申请对应的空间，并且能够直接内部调用构造函数生成对象。

### 关于new

new operator ：new操作符
例子：`A * a=new A;`
- 执行过程
  - 调用operator new（new 函数）分配内存，operator new (sizeof(A)) 
  - 调用构造函数生成类对象，A::A() 
  - 返回相应指针 
- 不能被重载

operator new ：new函数
有三种形式：
```C++
void* operator new (std::size_t size) throw (std::bad_alloc);
void* operator new (std::size_t size, const std::nothrow_t& nothrow_constant) throw();
void* operator new (std::size_t size, void* ptr) throw();
```
- 第一种分配size个字节的存储空间，并将对象类型进行内存对齐。如果成功，返回一个非空的指针指向首地址。失败抛出bad_alloc异常。
  - 调用方法：`A* a = new A;`
  - 可以被用户重载
- 第二种在分配失败时不抛出异常，它返回一个NULL指针。
  - 调用方法：`A* a = new(std::nothrow) A`
  - 可以被用户重载

- 第三种是placement new版本，它本质上是对operator new的重载，
  - 调用方法：`A* a =new (p) A()`
  - 不可以被用户重载
  - 与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。 
  - 定位生成对象时，会自动调用类A的构造函数，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的析构函数， 
  - 作用：创建对象(调用该类的构造函数)但是不分配内存，而是在已有的内存块上面创建对象。用于需要反复创建并删除的对象上，可以降低分配释放内存的性能消耗。
  - 应用场景举例：在一个server中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合c++的内存管理要求，没有什么错误，但是仔细想想很不合理，为什么我们每个请求都要重新申请一块内存呢，要知道每一次内存的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言），极端情况下，如果当前系统中有大量的内存碎片，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用placement new来构造对象，那么就会在我们指定的内存空间中构造对象。 
