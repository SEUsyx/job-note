# 引用

- 引用必须初始化
- 引用不能为空
- 引用不能更换目标
- 引用和指针的底层实现是一样的
  
### 左值引用
- 常规引用，一般表示对象身份

### 右值引用
右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。
右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：
- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

### 
右值：算式过程的中间值（主要是重载+-*/的类，基本类型的算式过程不堪一提），函数的返回值等等。
左值：具名对象即可。


### 引用折叠：
X& &、X& &&、X&& & 可折叠成 X&；  
X&& && 可折叠成 X&&；

### 右值引用的作用
在平时我们如果用左值引用去绑定一个对象，那么这个对象一定是具名对象。比如我们不能int& a= b+c; 这个b+c算式的过程，中实际上中间创建了一个新的变量，只是我们程序员看不到也无法对其操作，因为它不具名，一旦它完成算出b+c的结果然后传值给a后，它就会立马被释放（这就是所谓临时变量了）。 但是我们发现如果仅仅是int产生的临时变量，那对性能的影响几乎为0，但如果我们把它拓展到你自定义的一个类，而且这个类里面的数据很多，那么产生这样的临时变量的开销是巨大的！在没有右值引用之前，我们程序员对这个过程无可奈何，只能通过编译器去优化这一过程，但是当右值引用出现后，我们可以直接用右值引用延长这个临时变量的生命周期，这个时候我们便可对这个临时变量进行操作，很常见的优化过程就是通过在类的内部设置对应的右值处理逻辑，比如一个函数返回了一个vector对象，而且其中有100000个元素，这个时候我们为了防止临时对象的直接拷贝，通过设置对应的移动构造函数，将这个临时对象用右值引用将它的生命周期延长，然后再对它内部的数据直接进行迁移到我这个新建立的对象。这样就防止再创建一片新的空间去形成新的对象，而直接用原来的临时对象的内部空间，节省了拷贝构造的过程，大大提升了程序的效率。

