# 基于套接字的网络编程

linux下:

```C++ 
//建立套接字
int socket(int domain, int type, int protocol)；
```
- domain: 套接字中使用的协议族信息
    - PF_INET：IPv4互联网协议族
    - PF_INET6：IPv6互联网协议族
    - PF_LOCAL：本地通信的UNIX协议族
    - PF_PACKET：底层套接字的协议族
    - PF_IPX：IPX Novell协议族
- type: 套接字数据传输类型
    - 面向连接的 SOCK_STREAM：传输过程中数据不会丢失；按序传输数据；传输的数据不存在数据边界
    - 面向消息的 SOCK_DGRAM：强调快速传输而非传输顺序；传输的数据可能丢失也可能损毁；有数据边界；限制传输数据的大小
- protocol: 计算机间通信中使用的协议类型
    - IPPROTO_TCP：IPv4中面向连接的数据传输，默认为0
    - IPPROTP_UDP：IPv4中面向消息的数据传输
    - 其他
- 返回值：成功时返回文件描述符，失败时返回-1
    - 文件描述符：Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象
      - 重定向：重定向是把输出定向到文件或者标准流。管道是把一个程序的输出作为另一个程序的输入。 

```C++
struct sockaddr_in{
    sa_family_t     sin_family; //地址族
    uint16_t        sin_port;   //16位TCP/UDP端口号
    struct in_addr  sin_addr;   //32位IP地址
    char            sin_zero[8];    //不使用
}

struct in_addr{
    in_addr_t       s_addr      //32位IPv4地址
}

// 网络地址初始化
struct sockaddr_in addr; // 
char* serv_ip="211.217.168.13" //声明IP地址
char* serv_port="9190" //声明端口号
memset(&addr,0,sizeof(addr)); //结构体变量addr所有成员初始化为0
addr.sin_family=AF_INET; //指定地址族 
                        // AF_INET      IPv4网络协议中的地址族
                        // AF_INET6     IPv6网络协议中的地址族
                        // AF_LOCAL     本地通信中采用的UNIX协议地址族
addr.sin_addr.s_addr=inet_addr(serv_ip) //IP地址初始化 成功时返回32位大端序整数型值，失败时返回INADDR_NONE
                                        //INADDR_ANY: 自动获取运行服务器端的计算机IP地址
addr.sin_port=htons(atoi(serv_port)) // 端口初始化
                                     //h代表host，n代表network，s代表short，即把short类型数据从网络字节序转化为主机字节序
```


```C++
//向套接字分配网络地址
int bind(int sockfd， struct sockaddr* myaddr，socklen_t addrlen)；//成功时返回0，失败时返回-1
                                                                // 一般myaddr直接传入一个struct sockaddr_in并进行强制类型转换

struct sockaddr{
    sa_family_t     sin_family;    //地址族
    char            sa_data[14];    //地址信息
}
```

```C++
//进入等待连接状态
int listen(int sock，int backlog)   //成功时返回0，失败时返回-1
                                    //backlog表示连接请求的等待队列长度，表示最多使backlog个连接请求进入队列
```

```C++
//受理客户端请求
int accept(int sock，struct sockaddr* addr，socklen_t* addrlen)；//成功时返回创建的套接字文件描述符，失败时返回-1
                                    //addr是用来保存发起请求连接的客户端地址信息
                                    //addr_len是保存客户端地址信息的长度
```

```C++
//客户端请求连接
int connect(int sock，struct sockaddr* servaddr，socklen_t addrlen) //成功时返回0，失败时返回-1
                                    //servaddr：想要连接的服务器的地址
                                    //addrlen：以字节为单位传递的servaddr的长度
```

### 基于TCP的服务器端建立流程

- socket()  创建套接字
- bind()    分配套接字地址
- listen()  等待连接请求
- accept()  允许连接
- read()/write()    数据交换
- close()   断开连接
  
### 基于TCP客户端的建立流程

- socket()  创建套接字
- connect() 请求连接
- read()/write()    交换数据
- close()   关闭连接